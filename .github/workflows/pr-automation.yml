name: PR Automation

on:
  pull_request:
    types: [opened, edited, reopened, closed]

jobs:
  pr-automation:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
      contents: read
    steps:
      - name: PR Automation
        uses: actions/github-script@v6
        with:
          script: |
            const pr = context.payload.pull_request;
            const body = pr.body || '';
            const currentLabels = pr.labels.map(l => l.name);
            const prNumber = pr.number;
            
            // ========================================
            // 1. Type ë¼ë²¨ ì¶”ê°€
            // ========================================
            const typeLabels = ['feat', 'fix', 'refactor', 'docs', 'test', 'chore'];
            let checkedType = null;
            
            for (const type of typeLabels) {
              if (body.includes(`- [x] ${type}:`) || body.includes(`- [X] ${type}:`)) {
                checkedType = type;
                break;
              }
            }
            
            if (checkedType) {
              console.log(`âœ“ ì„ íƒëœ Type: ${checkedType}`);
            
              // ê¸°ì¡´ type ë¼ë²¨ ì œê±°
              const typeLabelsToRemove = currentLabels.filter(label => 
                typeLabels.includes(label) && label !== checkedType
              );
            
              for (const label of typeLabelsToRemove) {
                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    name: label
                  });
                  console.log(`ğŸ—‘ï¸ Removed type label: ${label}`);
                } catch (error) {
                  console.log(`âš ï¸ Failed to remove label ${label}`);
                }
              }
            
              // ìƒˆë¡œìš´ type ë¼ë²¨ ì¶”ê°€
              if (!currentLabels.includes(checkedType)) {
                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    labels: [checkedType.toUpperCase()]
                  });
                  console.log(`âœ… Added type label: ${checkedType}`);
                } catch (error) {
                  console.log(`âš ï¸ Failed to add label ${checkedType}`);
                }
              }
            } else {
              console.log('âš ï¸ Typeì´ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
            }
            
            // ========================================
            // 2. Priority ë¼ë²¨ ì¶”ê°€
            // ========================================
            const priorityLabels = ['P0', 'P1', 'P2', 'P3'];
            let checkedPriority = null;
            
            if (body.includes('- [x] P0') || body.includes('- [X] P0')) {
              checkedPriority = 'P0';
            } else if (body.includes('- [x] P1') || body.includes('- [X] P1')) {
              checkedPriority = 'P1';
            } else if (body.includes('- [x] P2') || body.includes('- [X] P2')) {
              checkedPriority = 'P2';
            } else if (body.includes('- [x] P3') || body.includes('- [X] P3')) {
              checkedPriority = 'P3';
            }
            
            if (checkedPriority) {
              console.log(`âœ“ ì„ íƒëœ Priority: ${checkedPriority}`);
            
              // ê¸°ì¡´ Priority ë¼ë²¨ ì œê±°
              const priorityLabelsToRemove = currentLabels.filter(label => 
                priorityLabels.includes(label) && label !== checkedPriority
              );
            
              for (const label of priorityLabelsToRemove) {
                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    name: label
                  });
                  console.log(`ğŸ—‘ï¸ Removed priority label: ${label}`);
                } catch (error) {
                  console.log(`âš ï¸ Failed to remove label ${label}`);
                }
              }
            
              // ìƒˆë¡œìš´ Priority ë¼ë²¨ ì¶”ê°€
              if (!currentLabels.includes(checkedPriority)) {
                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    labels: [checkedPriority]
                  });
                  console.log(`âœ… Added priority label: ${checkedPriority}`);
                } catch (error) {
                  console.log(`âš ï¸ Failed to add label ${checkedPriority}`);
                }
              }
            } else {
              console.log('âš ï¸ Priorityê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
            }
            
            // ========================================
            // 3. PR ì œëª© ìë™ ì—…ë°ì´íŠ¸ (opened ì‹œì—ë§Œ)
            // ========================================
            if (context.payload.action === 'opened' && checkedType) {
              const currentTitle = pr.title;
            
              // ì´ë¯¸ [type-ìˆ«ì] í˜•ì‹ì´ ìˆëŠ”ì§€ í™•ì¸
              const hasPrefix = /^\[.+-\d+\]/.test(currentTitle);
            
              if (!hasPrefix) {
                // í•´ë‹¹ typeì˜ ê°€ì¥ ìµœê·¼ PR ë²ˆí˜¸ ì°¾ê¸°
                const { data: allPRs } = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'all',
                  per_page: 100
                });
            
                // í•´ë‹¹ typeì˜ PRë“¤ë§Œ í•„í„°ë§
                const typePRs = allPRs.filter(p => {
                  const match = p.title.match(/^\[(\w+)-(\d+)\]/);
                  return match && match[1] === checkedType;
                });
            
                // ê°€ì¥ í° ë²ˆí˜¸ ì°¾ê¸°
                let maxNumber = 0;
                typePRs.forEach(p => {
                  const match = p.title.match(/^\[(\w+)-(\d+)\]/);
                  if (match) {
                    const num = parseInt(match[2]);
                    if (num > maxNumber) maxNumber = num;
                  }
                });
            
                const newNumber = maxNumber + 1;
                const newTitle = `[${checkedType}-${newNumber}] ${currentTitle}`;
            
                try {
                  await github.rest.pulls.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                    title: newTitle
                  });
                  console.log(`âœ… Updated PR title: ${newTitle}`);
                } catch (error) {
                  console.log(`âš ï¸ Failed to update PR title: ${error.message}`);
                }
              }
            }
            
            // ========================================
            // 4. PRì´ mergedë˜ë©´ ì—°ê²°ëœ Issueì— ì„±ê³µ ì½”ë©˜íŠ¸ ì¶”ê°€
            // ========================================
            if (context.payload.action === 'closed' && pr.merged) {
              console.log('âœ“ PRì´ mergedë˜ì—ˆìŠµë‹ˆë‹¤.');
            
              // "Closes #ìˆ«ì" íŒ¨í„´ ì°¾ê¸°
              const closesPattern = /(?:Closes|closes|Close|close|Fixed|fixed|Fix|fix|Resolved|resolved|Resolve|resolve)\s+#(\d+)/g;
              const matches = [...body.matchAll(closesPattern)];
            
              if (matches.length > 0) {
                for (const match of matches) {
                  const issueNumber = parseInt(match[1]);
            
                  try {
                    // Issueê°€ ì‹¤ì œë¡œ closeë˜ì—ˆëŠ”ì§€ í™•ì¸
                    const { data: issue } = await github.rest.issues.get({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber
                    });
            
                    if (issue.state === 'closed') {
                      // ì„±ê³µ ì½”ë©˜íŠ¸ ì¶”ê°€
                      await github.rest.issues.createComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issueNumber,
                        body: `âœ… ì´ ì´ìŠˆëŠ” PR #${prNumber} ì— ì˜í•´ ì„±ê³µì ìœ¼ë¡œ í•´ê²°ë˜ì—ˆìŠµë‹ˆë‹¤!\n\nğŸ‰ ì‘ì—…ì´ ì™„ë£Œë˜ì–´ ë°°í¬ë˜ì—ˆìŠµë‹ˆë‹¤.`
                      });
                      console.log(`âœ… Added success comment to issue #${issueNumber}`);
                    }
                  } catch (error) {
                    console.log(`âš ï¸ Failed to process issue #${issueNumber}: ${error.message}`);
                  }
                }
              } else {
                console.log('âš ï¸ "Closes #ìˆ«ì" íŒ¨í„´ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
              }
            }